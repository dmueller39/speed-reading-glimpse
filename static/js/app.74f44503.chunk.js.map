{"version":3,"sources":["src/gameLogic.js","src/common/WebKeyboardListener.web.js","src/common/LabelButton.js","src/common/Container.js","src/Level.js","src/Menu.js","src/SpeedReadingGlimpse.js","App.js","web-build/register-service-worker.js"],"names":["getTurn","letterCount","Array","fill","map","characters","randomIndex","Math","floor","random","length","substring","getCharacter","join","HAS_TOUCH_SCREEN","hasTouchScreen","navigator","maxTouchPoints","msMaxTouchPoints","mQ","window","matchMedia","media","matches","UA","userAgent","test","detectTouchScreen","componentDidMount","a","async","document","addEventListener","_onKeyDown","componentWillUnmount","removeEventListener","evt","key","props","inputKey","onKeyPress","View","this","children","React","getStyle","type","styles","positive","negative","neutral","LabelButton","onPress","label","disabled","style","Text","StyleSheet","create","padding","color","fontSize","Container","container","subcontainer","flex","justifyContent","marginHorizontal","height","maxWidth","width","Menu","state","currentIndex","mistakes","screenType","isCorrect","answerText","_didHandleAnswer","_onPreGlimpseTimeout","setState","_timeoutID","setTimeout","_onGlimpseTimeout","_onPostGlimpseTimeout","confirmAnswer","toLowerCase","game","turns","_onChangeAnswerText","_onKeyPress","nativeEvent","_onBlur","continueGame","onComplete","_renderIcon","isLast","word","answerContainer","TextInput","autoFocus","autoCapitalize","autoCorrect","autoComplete","onChangeText","textInput","onBlur","textAlign","compareContainer","alignItems","flexDirection","marginTop","marginBottom","hContainer","margin","inputContainer","backgroundColor","setGame","options","useState","showInfo","setShowInfo","infoButton","infoText","buttons","getGamePlan","name","labelButton","right","position","paddingLeft","paddingRight","paddingTop","alignSelf","OPTIONS","value","turnCount","getSpeedReadingGlimpsePlan","SpeedReadingGlimpse","result","inner","dataObject","activitysummary","resultsummary","data","JSON","stringify","dataStr","message","location","href","top","postMessage","App","serviceWorker","register","scope","then","info","catch","error","console"],"mappings":"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","file":"static/js/app.74f44503.chunk.js","sourcesContent":["// @flow\nimport type { SpeedReadingGlimpseGame } from \"./types\";\n\nconst ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n\nfunction getCharacter(characters: string) {\n  const randomIndex = Math.floor(Math.random() * characters.length);\n  return characters.substring(randomIndex, randomIndex + 1);\n}\n\nfunction getTurn(letterCount: number) {\n  return new Array(letterCount)\n    .fill(\"\")\n    .map(() => getCharacter(ALPHABET))\n    .join(\"\");\n}\n\n// game plan for speed reading should be an array of strings.\n// the player should see the contents of the string briefly,\n// and be asked to copy it\n//\n// We may eventually want to include meaningful words, but for now just do\n// characters\nexport function getSpeedReadingGlimpsePlan(\n  letterCount: number,\n  turnCount: number\n): SpeedReadingGlimpseGame {\n  const turns = new Array(turnCount).fill(\"\").map(() => getTurn(letterCount));\n  return {\n    letterCount,\n    turns,\n  };\n}\n","// @flow\nimport * as React from \"react\";\nimport { Dimensions } from \"react-native\";\nimport { View } from \"react-native\";\n\ntype Props = {\n  children?: React.Node,\n  inputKey: string,\n  onKeyPress: () => void,\n};\n\nfunction detectTouchScreen() {\n  var hasTouchScreen = false;\n  if (\"maxTouchPoints\" in navigator) {\n    hasTouchScreen = navigator.maxTouchPoints > 0;\n  } else if (\"msMaxTouchPoints\" in navigator) {\n    hasTouchScreen = (navigator: any).msMaxTouchPoints > 0;\n  } else {\n    var mQ = window.matchMedia && matchMedia(\"(pointer:coarse)\");\n    if (mQ && mQ.media === \"(pointer:coarse)\") {\n      hasTouchScreen = !!mQ.matches;\n    } else if (\"orientation\" in window) {\n      hasTouchScreen = true; // deprecated, but good fallback\n    } else {\n      // Only as a last resort, fall back to user agent sniffing\n      var UA = navigator.userAgent;\n      hasTouchScreen =\n        /\\b(BlackBerry|webOS|iPhone|IEMobile)\\b/i.test(UA) ||\n        /\\b(Android|Windows Phone|iPad|iPod)\\b/i.test(UA);\n    }\n  }\n  return hasTouchScreen;\n}\n\n/* this isn't 100% accurate for our needs. We actually want\nsomething like HAS_KEYBOARD and reverse the conditions below,\nBUT this is close enough for the time being. People on touch\nscreen laptops will be left in the cold :(\n*/\nconst HAS_TOUCH_SCREEN = detectTouchScreen();\n\nexport default class WebKeyboardListener extends React.Component<Props> {\n  componentDidMount = async () => {\n    if (!HAS_TOUCH_SCREEN) {\n      document.addEventListener(\"keydown\", this._onKeyDown);\n    }\n  };\n\n  componentWillUnmount = async () => {\n    if (!HAS_TOUCH_SCREEN) {\n      document.removeEventListener(\"keydown\", this._onKeyDown);\n    }\n  };\n\n  _onKeyDown = (evt: any) => {\n    if (evt.key == this.props.inputKey) {\n      this.props.onKeyPress();\n    }\n  };\n\n  render() {\n    if (!HAS_TOUCH_SCREEN) {\n      return <View>{this.props.children}</View>;\n    }\n    return null;\n  }\n}\n","// @flow\nimport * as React from \"react\";\n\nimport { StyleSheet, Text } from \"react-native\";\n\ntype ButtonType = \"positive\" | \"warning\" | \"negative\" | \"neutral\";\n\nfunction getStyle(type: ButtonType) {\n  switch (type) {\n    case \"positive\":\n      return styles.positive;\n    case \"negative\":\n      return styles.negative;\n  }\n  return styles.neutral;\n}\n\nexport default function LabelButton({\n  onPress,\n  type,\n  label,\n  disabled = false,\n  style,\n}: {\n  type: ButtonType,\n  onPress: () => void,\n  label: string,\n  disabled?: boolean,\n  style?: any,\n}) {\n  if (disabled) {\n    return <Text style={styles.disabled}>{label}</Text>;\n  }\n  return (\n    <Text style={[style, getStyle(type)]} onPress={onPress}>\n      {label}\n    </Text>\n  );\n}\n\nconst styles = StyleSheet.create({\n  positive: {\n    padding: 8,\n    color: \"green\",\n    fontSize: 24,\n  },\n  negative: {\n    padding: 8,\n    color: \"red\",\n    fontSize: 24,\n  },\n  neutral: {\n    padding: 8,\n    color: \"black\",\n    fontSize: 24,\n  },\n  disabled: {\n    padding: 8,\n    color: \"grey\",\n    fontSize: 24,\n  },\n});\n","// @flow\nimport * as React from \"react\";\n\nimport { StyleSheet, View } from \"react-native\";\n\nexport default function Container({ children }: { children?: ?any }) {\n  return (\n    <View style={styles.container}>\n      <View style={styles.subcontainer}>{children}</View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: \"flex-start\",\n  },\n  subcontainer: {\n    marginHorizontal: \"auto\",\n    height: \"100%\",\n    maxWidth: 600,\n    width: \"100%\",\n  },\n});\n","// @flow\nimport * as React from \"react\";\n\nimport {\n  Button,\n  StyleSheet,\n  Switch,\n  Text,\n  TouchableHighlight,\n  View,\n  Platform,\n  TextInput,\n} from \"react-native\";\nimport WebKeyboardListener from \"./common/WebKeyboardListener\";\n\nimport type {\n  SpeedReadingGlimpseGame,\n  SpeedReadingGlimpseGameResult,\n} from \"./types\";\nimport LabelButton from \"./common/LabelButton\";\nimport Container from \"./common/Container\";\n\nexport type Props = {|\n  onComplete: (SpeedReadingGlimpseGameResult) => void,\n  game: SpeedReadingGlimpseGame,\n|};\n\nconst PRE_GLIMPSE_SCREEN_TYPE = 1;\nconst GLIMPSE_SCREEN_TYPE = 2;\nconst POST_GLIMPSE_SCREEN_TYPE = 3;\nconst ENTRY_SCREEN_TYPE = 4;\nconst ANSWER_SCREEN_TYPE = 5;\n\ntype ScreenType = 0 | 1 | 2 | 3 | 4 | 5;\n\ntype State = {\n  currentIndex: number,\n  mistakes: number,\n  screenType: ScreenType,\n  isCorrect: boolean,\n  answerText: string,\n};\n\nexport default class Menu extends React.Component<Props, State> {\n  state = {\n    currentIndex: 0,\n    mistakes: 0,\n    screenType: PRE_GLIMPSE_SCREEN_TYPE,\n    isCorrect: false,\n    answerText: \"\",\n  };\n\n  _timeoutID: ?TimeoutID;\n  _didHandleAnswer: boolean = false;\n\n  componentDidMount() {\n    this._timeoutID = setTimeout(this._onPreGlimpseTimeout, 1000);\n  }\n\n  _onPreGlimpseTimeout = () => {\n    this.setState({\n      screenType: GLIMPSE_SCREEN_TYPE,\n    });\n    this._timeoutID = setTimeout(this._onGlimpseTimeout, 200);\n  };\n\n  _onGlimpseTimeout = () => {\n    this.setState({\n      screenType: POST_GLIMPSE_SCREEN_TYPE,\n    });\n    this._timeoutID = setTimeout(this._onPostGlimpseTimeout, 1000);\n  };\n\n  _onPostGlimpseTimeout = () => {\n    this._didHandleAnswer = false;\n    this.setState({\n      screenType: ENTRY_SCREEN_TYPE,\n    });\n  };\n\n  confirmAnswer = () => {\n    // handle race conditions that setState can't help with\n    if (!this._didHandleAnswer) {\n      this._didHandleAnswer = true;\n      const isCorrect =\n        this.state.answerText.toLowerCase() ===\n        this.props.game.turns[this.state.currentIndex].toLowerCase();\n      const mistakes = this.state.mistakes + (isCorrect ? 0 : 1);\n      this.setState({\n        mistakes,\n        screenType: ANSWER_SCREEN_TYPE,\n        isCorrect,\n      });\n    }\n  };\n\n  _onChangeAnswerText = (answerText: string) => {\n    this.setState({ answerText });\n  };\n\n  _onKeyPress = ({\n    nativeEvent: { key },\n  }: {\n    nativeEvent: { key: string },\n  }) => {\n    if (key == \"Enter\") {\n      this.confirmAnswer();\n    }\n  };\n\n  _onBlur = () => {\n    if (\n      this.state.answerText.length > 0 &&\n      // we also blur when we hit enter\n      this.state.screenType == ENTRY_SCREEN_TYPE\n    ) {\n      this.confirmAnswer();\n    }\n  };\n\n  continueGame = () => {\n    const currentIndex = this.state.currentIndex + 1;\n    const mistakes = this.state.mistakes;\n    if (currentIndex >= this.props.game.turns.length) {\n      this.props.onComplete({\n        mistakes,\n        length: this.props.game.turns.length,\n      });\n    } else {\n      this.setState({\n        answerText: \"\",\n        currentIndex,\n        isCorrect: false,\n        screenType: PRE_GLIMPSE_SCREEN_TYPE,\n      });\n      this._timeoutID = setTimeout(this._onPreGlimpseTimeout, 1000);\n    }\n  };\n\n  _renderIcon = () => {\n    if (this.state.screenType != ANSWER_SCREEN_TYPE) {\n      return null;\n    }\n    if (this.state.isCorrect) {\n      return <Text style={styles.answerText}>✅</Text>;\n    }\n    return <Text style={styles.answerText}>🚫</Text>;\n  };\n\n  render() {\n    const isLast = this.state.currentIndex + 1 >= this.props.game.turns.length;\n\n    switch (this.state.screenType) {\n      case 1:\n        return <Container></Container>;\n      case 2:\n        return (\n          <Container>\n            <Text style={styles.word}>\n              {this.props.game.turns[this.state.currentIndex]}\n            </Text>\n          </Container>\n        );\n      case 3:\n        return <Container></Container>;\n      case 4:\n        return (\n          <Container>\n            <View style={styles.answerContainer}>\n              <TextInput\n                autoFocus={true}\n                autoCapitalize=\"none\"\n                autoCorrect={false}\n                autoComplete=\"off\"\n                onChangeText={this._onChangeAnswerText}\n                onKeyPress={this._onKeyPress}\n                style={styles.textInput}\n                onBlur={this._onBlur}\n              />\n            </View>\n          </Container>\n        );\n      case 5:\n        return (\n          <Container>\n            <View style={styles.answerContainer}>{this._renderIcon()}</View>\n            <Text style={{ textAlign: \"center\" }}>\n              {this.state.answerText.toLowerCase()} /{\" \"}\n              {this.props.game.turns[this.state.currentIndex].toLowerCase()}\n            </Text>\n            <LabelButton\n              style={{ textAlign: \"center\" }}\n              label={isLast ? \"finish\" : \"next\"}\n              onPress={() => this.continueGame()}\n              type=\"positive\"\n            />\n          </Container>\n        );\n      default:\n        return <Container></Container>;\n    }\n  }\n}\n\nconst styles = StyleSheet.create({\n  compareContainer: {\n    alignItems: \"center\",\n    flexDirection: \"row\",\n  },\n  word: {\n    width: \"100%\",\n    textAlign: \"center\",\n    fontSize: 40,\n    marginTop: 40,\n    marginBottom: 40,\n  },\n  hContainer: {\n    flexDirection: \"row\",\n    padding: 8,\n    margin: \"auto\",\n    width: \"100%\",\n    justifyContent: \"center\",\n  },\n  inputContainer: {\n    alignItems: \"center\",\n  },\n  answerContainer: {\n    width: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  answerText: {\n    marginTop: 40,\n    marginBottom: 40,\n    fontSize: 40,\n  },\n  textInput: {\n    marginTop: 40,\n    marginBottom: 40,\n    fontSize: 40,\n    backgroundColor: \"white\",\n    textAlign: \"center\",\n  },\n});\n","// @flow\nimport React, { useState } from \"react\";\n\nimport {\n  Button,\n  StyleSheet,\n  Switch,\n  Text,\n  TouchableHighlight,\n  View,\n} from \"react-native\";\nimport type {\n  SpeedReadingGlimpseGameResult,\n  SpeedReadingGlimpseGame,\n} from \"./types\";\n\nimport LabelButton from \"./common/LabelButton\";\nimport Container from \"./common/Container\";\n\nexport type Props = {|\n  options: Array<{ getGamePlan: () => SpeedReadingGlimpseGame, name: string }>,\n  setGame: (SpeedReadingGlimpseGame) => void,\n|};\n\nexport default function Menu({ setGame, options }: Props) {\n  const [showInfo, setShowInfo] = useState(false);\n\n  if (showInfo) {\n    const onClosePress = () => setShowInfo(false);\n    return (\n      <Container>\n        <LabelButton\n          label=\"❎\"\n          onPress={onClosePress}\n          type=\"neutral\"\n          style={styles.infoButton}\n        />\n        <Text style={styles.infoText}>\n          Select the number of characters you'd like to remember.{\"\\n\"}\n          There will be 10 turns.{\"\\n\"}\n          Each turn you will be given a brief glimpse of characters to remember.\n          {\"\\n\"}\n          Retype the characters into the box and hit enter when you are done to\n          progress.{\"\\n\"}\n        </Text>\n      </Container>\n    );\n  }\n\n  const buttons = options.map(({ getGamePlan, name }) => {\n    return (\n      <LabelButton\n        key={name}\n        label={name}\n        onPress={() => setGame(getGamePlan())}\n        type=\"positive\"\n        style={styles.labelButton}\n      />\n    );\n  });\n\n  const onInfoPress = () => setShowInfo(true);\n\n  return (\n    <Container>\n      <LabelButton\n        label=\"ℹ️\"\n        onPress={onInfoPress}\n        type=\"neutral\"\n        style={styles.infoButton}\n      />\n      {buttons}\n    </Container>\n  );\n}\n\nconst styles = StyleSheet.create({\n  infoButton: { right: 5, position: \"absolute\" },\n  infoText: { paddingLeft: 5, paddingRight: 30, paddingTop: 5 },\n  labelButton: { alignSelf: \"center\" },\n});\n","// @flow\nimport React, { useState } from \"react\";\n\nimport type {\n  SpeedReadingGlimpseGameResult,\n  SpeedReadingGlimpseGame,\n} from \"./types\";\nimport { getSpeedReadingGlimpsePlan } from \"./gameLogic\";\nimport Level from \"./Level\";\nimport Menu from \"./Menu\";\n\nconst OPTIONS = [2, 3, 4, 5, 6, 7].map((value) => {\n  return {\n    name: \"\" + value,\n    getGamePlan: () => getSpeedReadingGlimpsePlan(value, 1),\n  };\n});\n\nexport default function SpeedReadingGlimpse() {\n  const [game, setGame] = useState((null: ?SpeedReadingGlimpseGame));\n  if (game == null) {\n    return <Menu options={OPTIONS} setGame={setGame} />;\n  } else {\n    const onComplete = (result: SpeedReadingGlimpseGameResult) => {\n      const inner = {\n        ...result,\n        letterCount: game == null ? 0 : game.turns[0].length,\n      };\n      const dataObject = {\n        type: \"game\",\n        activitysummary: `${inner.letterCount} letters, ${inner.length} turns`,\n        resultsummary: `${inner.length - inner.mistakes} / ${\n          inner.length\n        } correct`,\n        data: JSON.stringify(inner),\n      };\n      const dataStr = JSON.stringify(dataObject);\n      const message = window.location.href + \";complete;\" + dataStr;\n      window.top.postMessage(message, \"*\");\n\n      setTimeout(() => setGame(null), 1000);\n    };\n\n    return <Level game={game} onComplete={onComplete} />;\n  }\n}\n","// @flow\nimport * as React from \"react\";\nimport SpeedReadingGlimpse from \"./src/SpeedReadingGlimpse.js\";\n\nexport default function App(props: any) {\n  return <SpeedReadingGlimpse {...props} />;\n}\n","/* eslint-env browser */\n\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', function () {\n    navigator.serviceWorker\n      .register('/speed-reading-glimpse/expo-service-worker.js', { scope: '/speed-reading-glimpse/' })\n      .then(function (info) {\n        // console.info('Registered service-worker', info);\n      })\n      .catch(function (error) {\n        console.info('Failed to register service-worker', error);\n      });\n  });\n}\n"],"sourceRoot":""}