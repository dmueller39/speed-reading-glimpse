{"version":3,"sources":["src/gameLogic.js","src/common/WebKeyboardListener.web.js","src/common/LabelButton.js","src/common/Container.js","src/Level.js","src/Menu.js","src/SpeedReadingGlimpse.js","App.js","web-build/register-service-worker.js"],"names":["getTurn","letters","Array","fill","map","characters","randomIndex","Math","floor","random","length","substring","getCharacter","join","HAS_TOUCH_SCREEN","hasTouchScreen","navigator","maxTouchPoints","msMaxTouchPoints","mQ","window","matchMedia","media","matches","UA","userAgent","test","detectTouchScreen","componentDidMount","a","async","document","addEventListener","_onKeyDown","componentWillUnmount","removeEventListener","evt","key","props","inputKey","onKeyPress","View","this","children","React","getStyle","type","styles","positive","negative","neutral","LabelButton","onPress","label","disabled","style","Text","StyleSheet","create","padding","color","fontSize","Container","container","subcontainer","flex","justifyContent","marginHorizontal","height","maxWidth","width","Menu","state","currentIndex","mistakes","screenType","isCorrect","answerText","_onPreGlimpseTimeout","setState","_timeoutID","setTimeout","_onGlimpseTimeout","_onPostGlimpseTimeout","confirmAnswer","toLowerCase","game","turns","_onCorrectAnswerTimeout","continueGame","_onConfirmIncorrectAnswer","_onChangeAnswerText","_onKeyPress","nativeEvent","_onBlur","onComplete","_renderIcon","word","answerContainer","TextInput","autoFocus","autoCapitalize","onChangeText","textInput","onBlur","textAlign","marginTop","marginBottom","hContainer","flexDirection","margin","inputContainer","alignItems","backgroundColor","setGame","buttons","options","getGamePlan","name","labelButton","alignSelf","OPTIONS","value","SpeedReadingGlimpse","useState","result","location","href","split","App","serviceWorker","register","scope","then","info","catch","error","console"],"mappings":"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","file":"static/js/app.8a6745ac.chunk.js","sourcesContent":["// @flow\nimport type { SpeedReadingGlimpseGame } from \"./types\";\n\nconst ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n\nfunction getCharacter(characters: string) {\n  const randomIndex = Math.floor(Math.random() * characters.length);\n  return characters.substring(randomIndex, randomIndex + 1);\n}\n\nfunction getTurn(letters: number) {\n  return new Array(letters)\n    .fill(\"\")\n    .map(() => getCharacter(ALPHABET))\n    .join(\"\");\n}\n\n// game plan for speed reading should be an array of strings.\n// the player should see the contents of the string briefly,\n// and be asked to copy it\n//\n// We may eventually want to include meaningful words, but for now just do\n// characters\nexport function getSpeedReadingGlimpsePlan(\n  letters: number\n): SpeedReadingGlimpseGame {\n  const turns = new Array(10).fill(\"\").map(() => getTurn(letters));\n  return {\n    turns,\n  };\n}\n","// @flow\nimport * as React from \"react\";\nimport { Dimensions } from \"react-native\";\nimport { View } from \"react-native\";\n\ntype Props = {\n  children?: React.Node,\n  inputKey: string,\n  onKeyPress: () => void,\n};\n\nfunction detectTouchScreen() {\n  var hasTouchScreen = false;\n  if (\"maxTouchPoints\" in navigator) {\n    hasTouchScreen = navigator.maxTouchPoints > 0;\n  } else if (\"msMaxTouchPoints\" in navigator) {\n    hasTouchScreen = (navigator: any).msMaxTouchPoints > 0;\n  } else {\n    var mQ = window.matchMedia && matchMedia(\"(pointer:coarse)\");\n    if (mQ && mQ.media === \"(pointer:coarse)\") {\n      hasTouchScreen = !!mQ.matches;\n    } else if (\"orientation\" in window) {\n      hasTouchScreen = true; // deprecated, but good fallback\n    } else {\n      // Only as a last resort, fall back to user agent sniffing\n      var UA = navigator.userAgent;\n      hasTouchScreen =\n        /\\b(BlackBerry|webOS|iPhone|IEMobile)\\b/i.test(UA) ||\n        /\\b(Android|Windows Phone|iPad|iPod)\\b/i.test(UA);\n    }\n  }\n  return hasTouchScreen;\n}\n\n/* this isn't 100% accurate for our needs. We actually want\nsomething like HAS_KEYBOARD and reverse the conditions below,\nBUT this is close enough for the time being. People on touch\nscreen laptops will be left in the cold :(\n*/\nconst HAS_TOUCH_SCREEN = detectTouchScreen();\n\nexport default class WebKeyboardListener extends React.Component<Props> {\n  componentDidMount = async () => {\n    if (!HAS_TOUCH_SCREEN) {\n      document.addEventListener(\"keydown\", this._onKeyDown);\n    }\n  };\n\n  componentWillUnmount = async () => {\n    if (!HAS_TOUCH_SCREEN) {\n      document.removeEventListener(\"keydown\", this._onKeyDown);\n    }\n  };\n\n  _onKeyDown = (evt: any) => {\n    if (evt.key == this.props.inputKey) {\n      this.props.onKeyPress();\n    }\n  };\n\n  render() {\n    if (!HAS_TOUCH_SCREEN) {\n      return <View>{this.props.children}</View>;\n    }\n    return null;\n  }\n}\n","// @flow\nimport * as React from \"react\";\n\nimport { StyleSheet, Text } from \"react-native\";\n\ntype ButtonType = \"positive\" | \"warning\" | \"negative\" | \"neutral\";\n\nfunction getStyle(type: ButtonType) {\n  switch (type) {\n    case \"positive\":\n      return styles.positive;\n    case \"negative\":\n      return styles.negative;\n  }\n  return styles.neutral;\n}\n\nexport default function LabelButton({\n  onPress,\n  type,\n  label,\n  disabled = false,\n  style,\n}: {\n  type: ButtonType,\n  onPress: () => void,\n  label: string,\n  disabled?: boolean,\n  style?: any,\n}) {\n  if (disabled) {\n    return <Text style={styles.disabled}>{label}</Text>;\n  }\n  return (\n    <Text style={[style, getStyle(type)]} onPress={onPress}>\n      {label}\n    </Text>\n  );\n}\n\nconst styles = StyleSheet.create({\n  positive: {\n    padding: 8,\n    color: \"green\",\n    fontSize: 24,\n  },\n  negative: {\n    padding: 8,\n    color: \"red\",\n    fontSize: 24,\n  },\n  neutral: {\n    padding: 8,\n    color: \"black\",\n    fontSize: 24,\n  },\n  disabled: {\n    padding: 8,\n    color: \"grey\",\n    fontSize: 24,\n  },\n});\n","// @flow\nimport * as React from \"react\";\n\nimport { StyleSheet, View } from \"react-native\";\n\nexport default function Container({ children }: { children?: ?any }) {\n  return (\n    <View style={styles.container}>\n      <View style={styles.subcontainer}>{children}</View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: \"flex-start\",\n  },\n  subcontainer: {\n    marginHorizontal: \"auto\",\n    height: \"100%\",\n    maxWidth: 600,\n    width: \"100%\",\n  },\n});\n","// @flow\nimport * as React from \"react\";\n\nimport {\n  Button,\n  StyleSheet,\n  Switch,\n  Text,\n  TouchableHighlight,\n  View,\n  Platform,\n  TextInput,\n} from \"react-native\";\nimport WebKeyboardListener from \"./common/WebKeyboardListener\";\n\nimport type {\n  SpeedReadingGlimpseGame,\n  SpeedReadingGlimpseGameResult,\n} from \"./types\";\nimport LabelButton from \"./common/LabelButton\";\nimport Container from \"./common/Container\";\n\nexport type Props = {|\n  onComplete: (SpeedReadingGlimpseGameResult) => void,\n  game: SpeedReadingGlimpseGame,\n|};\n\nconst PRE_GLIMPSE_SCREEN_TYPE = 1;\nconst GLIMPSE_SCREEN_TYPE = 2;\nconst POST_GLIMPSE_SCREEN_TYPE = 3;\nconst ENTRY_SCREEN_TYPE = 4;\nconst ANSWER_SCREEN_TYPE = 5;\n\ntype ScreenType = 0 | 1 | 2 | 3 | 4 | 5;\n\ntype State = {\n  currentIndex: number,\n  mistakes: number,\n  screenType: ScreenType,\n  isCorrect: boolean,\n  answerText: string,\n};\n\nexport default class Menu extends React.Component<Props, State> {\n  state = {\n    currentIndex: 0,\n    mistakes: 0,\n    screenType: PRE_GLIMPSE_SCREEN_TYPE,\n    isCorrect: false,\n    answerText: \"\",\n  };\n\n  _timeoutID: ?TimeoutID;\n\n  componentDidMount() {\n    this._timeoutID = setTimeout(this._onPreGlimpseTimeout, 1000);\n  }\n\n  _onPreGlimpseTimeout = () => {\n    this.setState({\n      screenType: GLIMPSE_SCREEN_TYPE,\n    });\n    this._timeoutID = setTimeout(this._onGlimpseTimeout, 200);\n  };\n\n  _onGlimpseTimeout = () => {\n    this.setState({\n      screenType: POST_GLIMPSE_SCREEN_TYPE,\n    });\n    this._timeoutID = setTimeout(this._onPostGlimpseTimeout, 1000);\n  };\n\n  _onPostGlimpseTimeout = () => {\n    this.setState({\n      screenType: ENTRY_SCREEN_TYPE,\n    });\n  };\n\n  confirmAnswer = () => {\n    const isCorrect =\n      this.state.answerText.toLowerCase() ===\n      this.props.game.turns[this.state.currentIndex].toLowerCase();\n    const mistakes = this.state.mistakes + (isCorrect ? 0 : 1);\n    this.setState({\n      mistakes,\n      screenType: ANSWER_SCREEN_TYPE,\n      isCorrect,\n    });\n\n    this._timeoutID = setTimeout(this._onCorrectAnswerTimeout, 500);\n  };\n\n  _onCorrectAnswerTimeout = () => {\n    this.continueGame();\n  };\n\n  _onConfirmIncorrectAnswer = () => {\n    this.continueGame();\n  };\n\n  _onChangeAnswerText = (answerText: string) => {\n    this.setState({ answerText });\n  };\n\n  _onKeyPress = ({\n    nativeEvent: { key },\n  }: {\n    nativeEvent: { key: string },\n  }) => {\n    if (key == \"Enter\") {\n      this.confirmAnswer();\n    }\n  };\n\n  _onBlur = () => {\n    if (this.state.answerText.length > 0) {\n      this.confirmAnswer();\n    }\n  };\n\n  continueGame = () => {\n    const currentIndex = this.state.currentIndex + 1;\n    const mistakes = this.state.mistakes;\n    if (currentIndex >= this.props.game.turns.length) {\n      this.props.onComplete({\n        mistakes,\n        length: this.props.game.turns.length,\n      });\n    } else {\n      this.setState({\n        answerText: \"\",\n        currentIndex,\n        isCorrect: false,\n        screenType: PRE_GLIMPSE_SCREEN_TYPE,\n      });\n      this._timeoutID = setTimeout(this._onPreGlimpseTimeout, 1000);\n    }\n  };\n\n  _renderIcon = () => {\n    if (this.state.screenType != ANSWER_SCREEN_TYPE) {\n      return null;\n    }\n    if (this.state.isCorrect) {\n      return <Text style={styles.answerText}>✅</Text>;\n    }\n    return <Text style={styles.answerText}>🚫</Text>;\n  };\n\n  render() {\n    const answerIcon = this._renderIcon();\n    switch (this.state.screenType) {\n      case 1:\n        return <Container></Container>;\n      case 2:\n        return (\n          <Container>\n            <Text style={styles.word}>\n              {this.props.game.turns[this.state.currentIndex]}\n            </Text>\n          </Container>\n        );\n      case 3:\n        return <Container></Container>;\n      case 4:\n        return (\n          <Container>\n            <View style={styles.answerContainer}>\n              <TextInput\n                autoFocus={true}\n                autoCapitalize=\"none\"\n                onChangeText={this._onChangeAnswerText}\n                onKeyPress={this._onKeyPress}\n                style={styles.textInput}\n                onBlur={this._onBlur}\n              />\n            </View>\n          </Container>\n        );\n      case 5:\n        return (\n          <Container>\n            <View style={styles.answerContainer}>{this._renderIcon()}</View>\n          </Container>\n        );\n      default:\n        return <Container></Container>;\n    }\n  }\n}\n\nconst styles = StyleSheet.create({\n  word: {\n    width: \"100%\",\n    textAlign: \"center\",\n    fontSize: 40,\n    marginTop: 40,\n    marginBottom: 40,\n  },\n  hContainer: {\n    flexDirection: \"row\",\n    padding: 8,\n    margin: \"auto\",\n    width: \"100%\",\n    justifyContent: \"center\",\n  },\n  inputContainer: {\n    alignItems: \"center\",\n  },\n  answerContainer: {\n    width: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  answerText: {\n    marginTop: 40,\n    marginBottom: 40,\n    fontSize: 40,\n  },\n  textInput: {\n    marginTop: 40,\n    marginBottom: 40,\n    fontSize: 40,\n    backgroundColor: \"white\",\n    textAlign: \"center\",\n  },\n});\n","// @flow\nimport * as React from \"react\";\n\nimport {\n  Button,\n  StyleSheet,\n  Switch,\n  Text,\n  TouchableHighlight,\n  View,\n} from \"react-native\";\nimport type {\n  SpeedReadingGlimpseGameResult,\n  SpeedReadingGlimpseGame,\n} from \"./types\";\n\nimport LabelButton from \"./common/LabelButton\";\nimport Container from \"./common/Container\";\n\nexport type Props = {|\n  options: Array<{ getGamePlan: () => SpeedReadingGlimpseGame, name: string }>,\n  setGame: (SpeedReadingGlimpseGame) => void,\n|};\n\nexport default function Menu({ setGame, options }: Props) {\n  const buttons = options.map(({ getGamePlan, name }) => {\n    return (\n      <LabelButton\n        key={name}\n        label={name}\n        onPress={() => setGame(getGamePlan())}\n        type=\"positive\"\n        style={styles.labelButton}\n      />\n    );\n  });\n\n  /** todo, only render scrollview on iOS/Android */\n  return <Container>{buttons}</Container>;\n}\n\nconst styles = StyleSheet.create({ labelButton: { alignSelf: \"center\" } });\n","// @flow\nimport React, { useState } from \"react\";\n\nimport type {\n  SpeedReadingGlimpseGameResult,\n  SpeedReadingGlimpseGame,\n} from \"./types\";\nimport { getSpeedReadingGlimpsePlan } from \"./gameLogic\";\nimport Level from \"./Level\";\nimport Menu from \"./Menu\";\n\nimport type { StackNavigationProp, RouteProp } from \"@react-navigation/stack\";\n\nconst OPTIONS = [2, 3, 4, 5, 6, 7].map((value) => {\n  return {\n    name: \"\" + value,\n    getGamePlan: () => getSpeedReadingGlimpsePlan(value),\n  };\n});\n\nexport default function SpeedReadingGlimpse() {\n  const [game, setGame] = useState((null: ?SpeedReadingGlimpseGame));\n  if (game == null) {\n    return <Menu options={OPTIONS} setGame={setGame} />;\n  } else {\n    const onComplete = (result: SpeedReadingGlimpseGameResult) => {\n      window.location.href = window.location.href.split(\"#\")[0] + \"#complete=1\";\n      setGame(null);\n    };\n\n    return <Level game={game} onComplete={onComplete} />;\n  }\n}\n","// @flow\nimport * as React from \"react\";\nimport SpeedReadingGlimpse from \"./src/SpeedReadingGlimpse.js\";\n\nexport default function App(props: any) {\n  return <SpeedReadingGlimpse {...props} />;\n}\n","/* eslint-env browser */\n\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', function () {\n    navigator.serviceWorker\n      .register('/speed-reading-glimpse/expo-service-worker.js', { scope: '/speed-reading-glimpse/' })\n      .then(function (info) {\n        // console.info('Registered service-worker', info);\n      })\n      .catch(function (error) {\n        console.info('Failed to register service-worker', error);\n      });\n  });\n}\n"],"sourceRoot":""}